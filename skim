#!/usr/bin/env node


// Generated by CoffeeScript 1.4.0
var compare, correctType, currentDepth, currentLevel, doesExist, exec, fs, given, isDirString, isDirectory, isSearchable, locations, nextLevel, numFound, path, patterns, program, searchLocation, util, _ref, _ref1;

fs = require('fs');

path = require('path');

exec = require('child_process').exec;

util = require('util');

program = require('commander');

isDirectory = function(filePath) {
  var fileStats;
  fileStats = fs.statSync(filePath);
  return fileStats.isDirectory();
};

isDirString = function(filePath) {
  var _ref, _ref1;
  return isDirectory(filePath) && (((_ref = filePath[filePath.length - 1]) === '/' || _ref === '\\') || ((_ref1 = path.basename(filePath)) === '.' || _ref1 === '..'));
};

doesExist = function(filePath) {
  if (fs.existsSync != null) {
    return fs.existsSync(filePath);
  } else if (path.existsSync != null) {
    return path.existsSync(filePath);
  } else {
    throw "Node.js missing either path or fs existsSync";
  }
};

program.version('0.1.0').usage('[options] [where] <regexp ...>').option('-w, --where <path>', 'Path to start search in').option('-m, --max <n>', 'Maximum depth to search into, 1 is minimum', parseInt).option('-n, --number <n>', 'Return the first n results and stops', parseInt).option('-t, --top', 'Return the first result and all results at that depth').option('-d, --dir', 'Look for directories only').option('-f, --file', 'Look for files only').parse(process.argv);

program.on('--help', function() {
  return console.log("By default, tries to find all results. Search location" + "can also be specified in the first argument, but named" + "folders must end with '/' or '\\'.");
});

if ((_ref = program.max) == null) {
  program.max = Infinity;
}

if (!(program.where != null) && program.args.length > 1 && isDirString(program.args[0])) {
  program.where = program.args.shift();
}

if ((_ref1 = program.where) == null) {
  program.where = '.';
}

patterns = (function() {
  var _i, _len, _ref2, _results;
  _ref2 = program.args;
  _results = [];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    given = _ref2[_i];
    try {
      _results.push(new RegExp("^" + given + "$"));
    } catch (e) {
      console.error("Error using: " + given);
      console.error(e.message);
      _results.push(process.exit(1));
    }
  }
  return _results;
})();

isSearchable = function(filePath) {
  return isDirectory(filePath) && !(filePath.match(/(\.git|\.svn)$/) != null);
};

numFound = 0;

correctType = function(filePath) {
  var isDir;
  if (program.dir || program.file) {
    isDir = isDirectory(filePath);
    return program.dir && isDir || program.file && !isDir;
  }
  return true;
};

compare = function(filename, filePath) {
  var pattern, _i, _len;
  for (_i = 0, _len = patterns.length; _i < _len; _i++) {
    pattern = patterns[_i];
    if (filename.match(pattern) != null) {
      if (!correctType(filePath)) {
        return;
      }
      console.log(filePath);
      numFound++;
      if ((program.number != null) && numFound === program.number) {
        process.exit(0);
      }
      return;
    }
  }
};

currentDepth = 1;

currentLevel = 1;

nextLevel = 0;

locations = [];

searchLocation = function(dir) {
  var filePath, loc, _i, _len, _ref2;
  _ref2 = fs.readdirSync(dir);
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    loc = _ref2[_i];
    filePath = path.join(dir, loc);
    if (!doesExist(filePath)) {
      continue;
    }
    compare(loc, filePath);
    if (isSearchable(filePath)) {
      locations.push(filePath);
      nextLevel++;
    }
  }
  currentLevel--;
  if (currentLevel === 0) {
    currentLevel = nextLevel;
    nextLevel = 0;
    currentDepth++;
    if (numFound > 0 && program.top) {
      process.exit(0);
    }
  }
  if (currentDepth > program.max || locations.length === 0) {
    return;
  }
  return searchLocation(locations.shift());
};

if (!isDirectory(program.where)) {
  console.error("Given search location is not a directory");
  process.exit(1);
}

searchLocation(program.where);
