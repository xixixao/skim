#!/usr/bin/env node


// Generated by CoffeeScript 1.4.0
var compare, currentDepth, currentLevel, exec, fs, given, isDirectory, isSearchable, locations, nextLevel, path, patterns, program, searchLocation, success, util, _ref, _ref1;

fs = require('fs');

path = require('path');

exec = require('child_process').exec;

util = require('util');

program = require('commander');

isDirectory = function(filePath) {
  var fileStats, _ref, _ref1;
  fileStats = fs.statSync(filePath);
  return fileStats.isDirectory() && (((_ref = filePath[filePath.length - 1]) === '/' || _ref === '\\') || ((_ref1 = path.basename(filePath)) === '.' || _ref1 === '..'));
};

program.version('0.1.0').usage('[options] [where] <regexp ...>').option('-w, --where <path>', 'Path to start search in').option('-d, --depth <n>', 'Maximum depth to search into, 1 is minimum', parseInt).option('-f, --first', 'Return the first result and stop').option('-t, --top', 'Return the first result and all results at that depth').parse(process.argv);

program.on('--help', function() {
  return console.log("By default, tries to find all results. Search location" + "can also be specified in the first argument, but named" + "folders must end with '/' or '\\'.");
});

if ((_ref = program.depth) == null) {
  program.depth = Infinity;
}

if (!(program.where != null) && program.args.length > 1 && isDirectory(program.args[0])) {
  program.where = program.args.shift();
}

if ((_ref1 = program.where) == null) {
  program.where = '.';
}

patterns = (function() {
  var _i, _len, _ref2, _results;
  _ref2 = program.args;
  _results = [];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    given = _ref2[_i];
    try {
      _results.push(new RegExp("^" + given + "$"));
    } catch (e) {
      console.error("Error using: " + given);
      console.error(e.message);
      _results.push(process.exit(1));
    }
  }
  return _results;
})();

isSearchable = function(filePath) {
  var fileStats;
  fileStats = fs.statSync(filePath);
  return fileStats.isDirectory() && !(filePath.match(/(\.git|\.svn)$/) != null);
};

success = false;

compare = function(filename, filePath) {
  var pattern, _i, _len;
  for (_i = 0, _len = patterns.length; _i < _len; _i++) {
    pattern = patterns[_i];
    if (filename.match(pattern) != null) {
      console.log(filePath);
      success = true;
      if (program.first) {
        process.exit(0);
      }
      return;
    }
  }
};

currentDepth = 1;

currentLevel = 1;

nextLevel = 0;

locations = [];

searchLocation = function(dir) {
  var filePath, loc, _i, _len, _ref2;
  _ref2 = fs.readdirSync(dir);
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    loc = _ref2[_i];
    filePath = path.join(dir, loc);
    compare(loc, filePath);
    if (isSearchable(filePath)) {
      locations.push(filePath);
      nextLevel++;
    }
  }
  currentLevel--;
  if (currentLevel === 0) {
    currentLevel = nextLevel;
    nextLevel = 0;
    currentDepth++;
    if (success && program.top) {
      process.exit(0);
    }
  }
  if (currentDepth > program.depth || locations.length === 0) {
    return;
  }
  return searchLocation(locations.shift());
};

if (!isDirectory(program.where)) {
  console.error("Given search location is not a directory");
  process.exit(1);
}

searchLocation(program.where);
